[
    {
        "test_summary": "The code is intended to compute the intersecting squares between two points on a grid, taking into account different scenarios such as diagonal movement, movement through negative coordinates, and movements with slopes less than, equal to, and greater than 1.",
        "function_names": "compute_intersecting_squares",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    dx, dy = x1 - x0, y1 - y0\n    is_steep = abs(dy) > abs(dx)\n    if is_steep:\n        x0, y0 = y0, x0\n        x1, y1 = y1, x1\n        dx, dy = dy, dx\n    swapped = False\n    if x0 > x1:\n        x0, x1 = x1, x0\n        y0, y1 = y1, y0\n        swapped = True\n    gradient = dy / dx\n    intersecting_points = []\n    y = y0\n    for x in range(x0 + 1, x1):\n        if is_steep:\n            if swapped:\n                intersecting_points.append((y, x))\n            else:\n                intersecting_points.append((x, y))\n        else:\n            if swapped:\n                intersecting_points.append((y, x))\n            else:\n                intersecting_points.append((x, y))\n        y += gradient\n        y = round(y)\n    if swapped:\n        intersecting_points = [(y, x) for x, y in intersecting_points]\n    return intersecting_points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "All tests failed, indicating issues with the algorithm's handling of different slopes, negative coordinates, and possibly the initial setup for steep slopes and swapped points.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "Each test failed due to incorrect calculations of intersecting squares. The issues range from not correctly handling slopes, both positive and negative, to not properly calculating intersections for both steep and gentle slopes. The failures indicate that the algorithm does not correctly adjust the coordinates for steep slopes or properly manage the gradient calculation and subsequent y-coordinate rounding for each step along the path.",
        "missing_functionality": "To address the failing tests, the algorithm needs to correctly handle: 1) Diagonal movements by ensuring the gradient is applied correctly and points are rounded and swapped back if necessary. 2) Movements through negative coordinates, ensuring that the algorithm correctly handles negative slopes and coordinates. 3) Slopes less than, equal to, and greater than 1, ensuring that it can accurately calculate intersecting squares for both steep and gentle slopes. Additionally, the algorithm must start its calculation from the correct initial square and include both the starting and ending points in its output if they are part of the grid.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    dx, dy = x1 - x0, y1 - y0\n    is_steep = abs(dy) > abs(dx)\n    if is_steep:\n        x0, y0 = y0, x0\n        x1, y1 = y1, x1\n        dx, dy = dy, dx\n    swapped = False\n    if x0 > x1:\n        x0, x1 = x1, x0\n        y0, y1 = y1, y0\n        swapped = True\n    gradient = dy / dx if dx != 0 else dy\n    intersecting_points = []\n    y = y0\n    if dx != 0:\n        for x in range(x0, x1 + 1):\n            if is_steep:\n                if swapped:\n                    intersecting_points.append((round(y), x))\n                else:\n                    intersecting_points.append((x, round(y)))\n            else:\n                if swapped:\n                    intersecting_points.append((x, round(y)))\n                else:\n                    intersecting_points.append((round(y), x))\n            y += gradient\n    else:  # Handle vertical lines\n        for y in range(min(y0, y1), max(y0, y1) + 1):\n            intersecting_points.append((x0, y))\n    if swapped and not is_steep:\n        intersecting_points = [(y, x) for x, y in intersecting_points]\n    return intersecting_points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "No tests passed. The algorithm failed to correctly calculate the intersecting squares for various slopes and did not handle negative coordinates or vertical lines properly.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "All tests failed due to the algorithm incorrectly calculating the intersecting squares. The primary issues were incorrect handling of slopes (both positive and negative), not properly addressing negative coordinates, and mismanagement of steep slopes versus gentle slopes.",
        "missing_functionality": "To make the failing tests pass, the algorithm needs to: 1) Correctly handle diagonal movements, ensuring accurate gradient application and rounding of points. 2) Properly manage movements through negative coordinates, ensuring negative slopes and coordinates are correctly addressed. 3) Accurately calculate intersecting squares for both steep and gentle slopes, ensuring that all positional arguments are used and both the starting and ending points are included in the output if they are part of the grid.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    dx, dy = x1 - x0, y1 - y0\n    is_steep = abs(dy) > abs(dx)\n    if is_steep:\n        x0, y0 = y0, x0\n        x1, y1 = y1, x1\n        dx, dy = dy, dx\n    swapped = False\n    if x0 > x1:\n        x0, x1 = x1, x0\n        y0, y1 = y1, y0\n        swapped = True\n    gradient = dy / dx if dx != 0 else dy\n    intersecting_points = []\n    y = y0\n    if dx != 0:\n        for x in range(x0, x1 + 1):\n            current_x, current_y = (round(y), x) if is_steep else (x, round(y))\n            if swapped:\n                current_x, current_y = current_y, current_x\n            intersecting_points.append((current_x, current_y))\n            y += gradient\n    else:  # Handle vertical lines\n        for y in range(min(y0, y1), max(y0, y1) + 1):\n            intersecting_points.append((x0, y))\n    return intersecting_points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "No tests passed. The provided code did not correctly calculate the intersecting squares for various slopes and did not handle negative coordinates or vertical lines properly.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "All tests failed due to the algorithm incorrectly calculating the intersecting squares. The primary issues were incorrect handling of slopes (both positive and negative), not properly addressing negative coordinates, and mismanagement of steep slopes versus gentle slopes. The algorithm also incorrectly included the starting and ending points in some cases where it should not have.",
        "missing_functionality": "To make the failing tests pass, the algorithm needs to: 1) Exclude the starting point from the list of intersecting squares unless it is explicitly part of the expected output. 2) Correctly handle diagonal movements, ensuring accurate gradient application and rounding of points. 3) Properly manage movements through negative coordinates, ensuring negative slopes and coordinates are correctly addressed. 4) Accurately calculate intersecting squares for both steep and gentle slopes, ensuring that all positional arguments are used and both the starting and ending points are included in the output if they are part of the grid, but excluding them when they are not supposed to be included.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    dx, dy = x1 - x0, y1 - y0\n    is_steep = abs(dy) > abs(dx)\n    if is_steep:\n        x0, y0 = y0, x0\n        x1, y1 = y1, x1\n        dx, dy = dy, dx\n    swapped = False\n    if x0 > x1:\n        x0, x1 = x1, x0\n        y0, y1 = y1, y0\n        swapped = True\n    gradient = dy / dx if dx != 0 else 0\n    intersecting_points = []\n    y = y0\n    if dx != 0:\n        for x in range(x0 + (0 if swapped else 1), x1 + (1 if not swapped else 0)):\n            current_x, current_y = (round(y), x) if is_steep else (x, round(y))\n            if swapped:\n                current_x, current_y = current_y, current_x\n            intersecting_points.append((current_x, current_y))\n            y += gradient\n    else:  # Handle vertical lines\n        for y in range(min(y0, y1) + 1, max(y0, y1) + 1):\n            intersecting_points.append((x0, y))\n    return intersecting_points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "No tests passed. The provided code did not correctly calculate the intersecting squares for various slopes and did not handle negative coordinates or vertical lines properly.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "All tests failed due to the algorithm incorrectly calculating the intersecting squares. The primary issues were incorrect handling of slopes (both positive and negative), not properly addressing negative coordinates, and mismanagement of steep slopes versus gentle slopes. The algorithm also incorrectly included the starting and ending points in some cases where it should not have.",
        "missing_functionality": "To make the failing tests pass, the algorithm needs to: 1) Exclude the starting point from the list of intersecting squares unless it is explicitly part of the expected output. 2) Correctly handle diagonal movements, ensuring accurate gradient application and rounding of points. 3) Properly manage movements through negative coordinates, ensuring negative slopes and coordinates are correctly addressed. 4) Accurately calculate intersecting squares for both steep and gentle slopes, ensuring that all positional arguments are used and both the starting and ending points are included in the output if they are part of the grid, but excluding them when they are not supposed to be included.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    dx, dy = x1 - x0, y1 - y0\n    is_steep = abs(dy) > abs(dx)\n    if is_steep:\n        x0, y0 = y0, x0\n        x1, y1 = y1, x1\n        dx, dy = dy, dx\n    swapped = False\n    if x0 > x1:\n        x0, x1 = x1, x0\n        y0, y1 = y1, y0\n        swapped = True\n    gradient = dy / dx if dx != 0 else 0\n    intersecting_points = []\n    y = y0\n    if dx != 0:\n        for x in range(x0 + (0 if swapped else 1), x1 + (1 if not swapped else 0)):\n            current_x, current_y = (round(y), x) if is_steep else (x, round(y))\n            if swapped:\n                current_x, current_y = current_y, current_x\n            intersecting_points.append((current_x, current_y))\n            y += gradient\n    else:  # Handle vertical lines\n        for y in range(min(y0, y1) + 1, max(y0, y1)):\n            intersecting_points.append((x0, y))\n    return intersecting_points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "No tests passed. The provided code failed to handle the calculation of intersecting squares correctly for various types of slopes, did not manage negative coordinates accurately, and did not exclude the start and end points appropriately.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "All tests failed due to several reasons: incorrect calculation of intersecting squares for different slopes, mismanagement of negative coordinates, and improper inclusion of start and end points in certain scenarios.",
        "missing_functionality": "To pass the failing tests, the algorithm needs to correctly handle the exclusion of the starting point and the inclusion of the ending point as per the specific requirements of each test case. It must accurately calculate the intersecting squares for different slopes, including handling both positive and negative slopes and coordinates. The algorithm also needs to ensure that it does not include points that are not part of the expected output.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    dx, dy = x1 - x0, y1 - y0\n    is_steep = abs(dy) > abs(dx)\n    if is_steep:\n        x0, y0 = y0, x0\n        x1, y1 = y1, x1\n        dx, dy = dy, dx\n    swapped = False\n    if x0 > x1:\n        x0, x1 = x1, x0\n        y0, y1 = y1, y0\n        swapped = True\n    gradient = dy / dx if dx != 0 else 0\n    intersecting_points = []\n    y = y0\n    x_start = x0 + (0 if swapped else 1)\n    x_end = x1 + (1 if not swapped else 0)\n    if dx != 0:\n        for x in range(x_start, x_end):\n            current_x, current_y = (round(y), x) if is_steep else (x, round(y))\n            if swapped:\n                current_x, current_y = current_y, current_x\n            if (current_x, current_y) != starting_point and (current_x, current_y) != ending_point:\n                intersecting_points.append((current_x, current_y))\n            y += gradient\n        if ending_point not in intersecting_points and x0 != x1:\n            intersecting_points.append(ending_point)\n    else:  # Handle vertical lines\n        for y in range(min(y0, y1) + 1, max(y0, y1)):\n            if (x0, y) != starting_point and (x0, y) != ending_point:\n                intersecting_points.append((x0, y))\n        if ending_point not in intersecting_points and y0 != y1:\n            intersecting_points.append(ending_point)\n    return intersecting_points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "No tests passed. The provided code failed to accurately calculate the intersecting squares for various types of slopes, mismanaged negative coordinates, and incorrectly included or excluded the start and end points.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "All tests failed due to incorrect calculation of intersecting squares for different slopes, mismanagement of negative coordinates, and improper inclusion or exclusion of start and end points. Specific issues include: \n- 'test_diagonal' and 'test_negative_diagonal' failed because the algorithm did not correctly exclude the starting point or include the ending point for diagonal movements. \n- 'test_half_slope' and 'test_slope_less_than_1' failed because the algorithm did not correctly handle slopes less than 1, leading to incorrect points being included. \n- 'test_partial_negative_diagonal' failed due to incorrect handling of diagonals with negative slopes, resulting in extra or missing points. \n- 'test_slope_greater_than_1' failed because the algorithm did not correctly handle slopes greater than 1, leading to missing or extra points.",
        "missing_functionality": "The algorithm needs to: \n1. Correctly exclude the starting point and include the ending point, adjusting for both positive and negative slopes. \n2. Accurately calculate intersecting squares for slopes less than, equal to, and greater than 1, including handling vertical and horizontal lines correctly. \n3. Handle negative coordinates correctly, ensuring that the calculation of intersecting squares works for both positive and negative directions.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    dx, dy = x1 - x0, y1 - y0\n    points = []\n    if dx == 0:  # Vertical line\n        step = 1 if y1 > y0 else -1\n        for y in range(y0 + step, y1 + step, step):\n            points.append((x0, y))\n    elif dy == 0:  # Horizontal line\n        step = 1 if x1 > x0 else -1\n        for x in range(x0 + step, x1 + step, step):\n            points.append((x, y0))\n    else:  # Diagonal or other slope\n        slope = dy / dx\n        step_x = 1 if dx > 0 else -1\n        step_y = 1 if dy > 0 else -1\n        y = y0\n        for x in range(x0, x1, step_x):\n            if slope >= 1 or slope <= -1:\n                for y_step in range(y0, y1, step_y):\n                    points.append((x, y_step))\n                y0 += step_y\n            else:\n                y += slope * step_x\n                points.append((x, round(y)))\n    if ending_point not in points:\n        points.append(ending_point)\n    if starting_point in points:\n        points.remove(starting_point)\n    return points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "No tests passed. The provided code failed to accurately calculate the intersecting squares for various types of slopes, mismanaged negative coordinates, and incorrectly included or excluded the start and end points.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "All tests failed due to incorrect calculation of intersecting squares for different slopes, mismanagement of negative coordinates, and improper inclusion or exclusion of start and end points. Specific issues include: \n- 'test_diagonal' and 'test_negative_diagonal' failed because the algorithm did not correctly exclude the starting point or include the ending point for diagonal movements. \n- 'test_half_slope' and 'test_slope_less_than_1' failed because the algorithm did not correctly handle slopes less than 1, leading to incorrect points being included. \n- 'test_partial_negative_diagonal' failed due to incorrect handling of diagonals with negative slopes, resulting in extra or missing points. \n- 'test_slope_greater_than_1' failed because the algorithm did not correctly handle slopes greater than 1, leading to missing or extra points.",
        "missing_functionality": "The algorithm needs to: \n1. Correctly exclude the starting point and include the ending point, adjusting for both positive and negative slopes. \n2. Accurately calculate intersecting squares for slopes less than, equal to, and greater than 1, including handling vertical and horizontal lines correctly. \n3. Handle negative coordinates correctly, ensuring that the calculation of intersecting squares works for both positive and negative directions.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    points = []\n    if x0 == x1:  # Vertical line\n        for y in range(min(y0, y1) + 1, max(y0, y1)):\n            points.append((x0, y))\n    elif y0 == y1:  # Horizontal line\n        for x in range(min(x0, x1) + 1, max(x0, x1)):\n            points.append((x, y0))\n    else:\n        dx, dy = x1 - x0, y1 - y0\n        slope = dy / dx\n        if abs(slope) == 1:\n            step_x = 1 if dx > 0 else -1\n            step_y = 1 if dy > 0 else -1\n            x, y = x0, y0\n            while x != x1:\n                x += step_x\n                y += step_y\n                points.append((x, y))\n        elif abs(slope) > 1:\n            step_y = 1 if dy > 0 else -1\n            y = y0\n            for x in range(x0 + step_y, x1, step_y):\n                y += slope\n                if y % 1 == 0:\n                    points.append((x, int(y)))\n        else:\n            step_x = 1 if dx > 0 else -1\n            x = x0\n            for y in range(y0 + step_x, y1, step_x):\n                x += 1/slope\n                if x % 1 == 0:\n                    points.append((int(x), y))\n    return points"
    },
    {
        "passing_tests": "None",
        "passing_tests_summary": "No tests passed. The initial code provided failed across all test scenarios due to incorrect logic in handling various types of slopes, mismanagement of negative coordinates, and improper handling of start and end points.",
        "failing_tests": "test_diagonal, test_half_slope, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "All tests failed due to multiple reasons: \n- Diagonal tests ('test_diagonal', 'test_negative_diagonal', 'test_partial_negative_diagonal') failed because the code improperly included the ending point. \n- Tests with slopes ('test_half_slope', 'test_slope_less_than_1', 'test_slope_greater_than_1') failed due to incorrect calculation of points for given slopes, particularly not accounting for slopes less than or greater than 1 correctly, and not handling vertical and horizontal lines appropriately.",
        "missing_functionality": "To pass all failing tests, the code needs to: \n1. Exclude the starting point and correctly include the ending point for all types of movements. \n2. Accurately calculate intersecting squares for all types of slopes, including handling of vertical and horizontal lines. \n3. Correctly handle negative coordinates and directions. \n4. Ensure that the algorithm works for both positive and negative slopes, and for slopes that are less than, equal to, or greater than 1.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    points = []\n    dx, dy = x1 - x0, y1 - y0\n    if dx == 0:  # Vertical line\n        step = 1 if dy > 0 else -1\n        for y in range(y0 + step, y1 + step, step):\n            points.append((x0, y))\n    elif dy == 0:  # Horizontal line\n        step = 1 if dx > 0 else -1\n        for x in range(x0 + step, x1 + step, step):\n            points.append((x, y0))\n    else:\n        slope = dy / dx\n        step_x = 1 if dx > 0 else -1\n        step_y = 1 if dy > 0 else -1\n        if abs(slope) == 1:\n            x, y = x0, y0\n            while (x != x1) and (y != y1):\n                x += step_x\n                y += step_y\n                points.append((x, y))\n        elif abs(slope) > 1:\n            for y in range(y0 + step_y, y1, step_y):\n                x = x0 + int((y - y0) / slope)\n                points.append((x, y))\n        else:\n            for x in range(x0 + step_x, x1, step_x):\n                y = y0 + int(slope * (x - x0))\n                points.append((x, y))\n    return points"
    },
    {
        "passing_tests": "test_half_slope",
        "passing_tests_summary": "The test 'test_half_slope' passed because the code correctly calculates points for a slope of 1/2, iterating over the x-coordinates and calculating the corresponding y-coordinates based on the slope.",
        "failing_tests": "test_diagonal, test_negative_diagonal, test_partial_negative_diagonal, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "Diagonal tests failed because the code incorrectly includes the ending point. The 'test_slope_greater_than_1' and 'test_slope_less_than_1' failed due to improper calculation of points for slopes greater and less than 1, respectively, not accurately reflecting the required number of points along the x and y axes.",
        "missing_functionality": "To pass all failing tests, the code needs to: 1. Exclude the ending point for diagonal movements. 2. For slopes greater than 1, ensure it iterates correctly over y-coordinates and calculates the corresponding x-coordinates, including all necessary points. 3. For slopes less than 1, correctly iterate over x-coordinates and calculate the corresponding y-coordinates, including all necessary points.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    points = []\n    dx, dy = x1 - x0, y1 - y0\n    if dx == 0:  # Vertical line\n        step = 1 if dy > 0 else -1\n        for y in range(y0 + step, y1, step):\n            points.append((x0, y))\n    elif dy == 0:  # Horizontal line\n        step = 1 if dx > 0 else -1\n        for x in range(x0 + step, x1, step):\n            points.append((x, y0))\n    else:\n        slope = dy / dx\n        step_x = 1 if dx > 0 else -1\n        step_y = 1 if dy > 0 else -1\n        if abs(slope) == 1:\n            x, y = x0 + step_x, y0 + step_y\n            while (x != x1) and (y != y1):\n                points.append((x, y))\n                x += step_x\n                y += step_y\n        elif abs(slope) > 1:\n            for y in range(y0 + step_y, y1, step_y):\n                x = x0 + int(round((y - y0) * dx / dy))\n                points.append((x, y))\n        else:\n            for x in range(x0 + step_x, x1, step_x):\n                y = y0 + int(round(slope * (x - x0)))\n                points.append((x, y))\n    return points"
    },
    {
        "passing_tests": "test_diagonal, test_negative_diagonal, test_partial_negative_diagonal",
        "passing_tests_summary": "These tests passed because the code correctly handles diagonal movements by iterating over both x and y coordinates simultaneously for a slope of 1, as well as handling negative slopes by adjusting the step values for both x and y directions appropriately. The code also successfully excludes the ending point for these scenarios.",
        "failing_tests": "test_half_slope, test_slope_greater_than_1, test_slope_less_than_1",
        "failing_tests_summary": "The 'test_half_slope' failed due to incorrect calculation of y-coordinates for a slope less than 1, resulting in inaccurate point generation. The 'test_slope_greater_than_1' failed because it did not correctly iterate over y-coordinates for slopes greater than 1, missing some points. The 'test_slope_less_than_1' failed due to not including all necessary points for slopes less than 1, specifically at the start and in between the x-coordinates.",
        "missing_functionality": "To pass all failing tests, the code must: 1. Correctly calculate and include all points for slopes less than 1, ensuring that it rounds or calculates y-coordinates appropriately to include intermediate points. 2. For slopes greater than 1, iterate correctly over y-coordinates and calculate the corresponding x-coordinates, including intermediate points and the start point if necessary. 3. Ensure that all positional arguments are used correctly and that the algorithm accounts for both increasing and decreasing slopes.",
        "code": "def compute_intersecting_squares(starting_point, ending_point):\n    x0, y0 = starting_point\n    x1, y1 = ending_point\n    points = []\n    dx, dy = x1 - x0, y1 - y0\n    if dx == 0:  # Vertical line\n        step = 1 if dy > 0 else -1\n        for y in range(y0 + step, y1, step):\n            points.append((x0, y))\n    elif dy == 0:  # Horizontal line\n        step = 1 if dx > 0 else -1\n        for x in range(x0 + step, x1, step):\n            points.append((x, y0))\n    else:\n        slope = dy / dx\n        step_x = 1 if dx > 0 else -1\n        step_y = 1 if dy > 0 else -1\n        if abs(slope) == 1:\n            x, y = x0, y0\n            while (x != x1 - step_x) and (y != y1 - step_y):\n                x += step_x\n                y += step_y\n                points.append((x, y))\n        elif abs(slope) > 1:\n            y = y0\n            while y != y1 - step_y:\n                y += step_y\n                x = x0 + int(round((y - y0) * dx / dy))\n                points.append((x, y))\n        else:\n            x = x0\n            while x != x1 - step_x:\n                x += step_x\n                y = y0 + int(round((y - y0) * dx / dy))\n                if (x, y) not in points:\n                    points.append((x, y))\n    return points"
    }
]